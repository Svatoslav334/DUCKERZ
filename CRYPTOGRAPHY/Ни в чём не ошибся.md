# Ни в чём не ошибся

### Описание

### Я реализовал классический алгоритм шифрования RSA, но у меня ощущение, что в конце я немного ошибся...

В вложении добавлен zip архив. Распаковать можно его командой 
```unzip Safest_RSA.zip -d Safest_RSA```

Распаковав мы увидим два файла:
- encoder.py
- out.txt

Рассмотрим файл encoder.py:
```
from Crypto.Util.number import getPrime, bytes_to_long 
from secret import flag

FLAG = bytes_to_long(flag)

p = getPrime(1024) # генерация случайного простого числа 1024 бита
q = getPrime(1024)
n = p * q
e = 2**16 + 1
ct = pow(FLAG, e, n) # ct = (ct^d) mod n)

print(f'n: {n}')
print(f'e: {e + p}')
print(f'ct: {ct}')
```

Дальше предоставлен скрипт, который расшифрует сообщение
```
from math import gcd

n = 18798751967178426381504731083645551181218121488252117174796390511662473223223405610358317360347533449725615650254937132757565862618074878444613133832079916631885992852274828236728617177721086544314236544562012971734513398321560619671317933405328568764783210898904175003033756768051691521868667268800572467570661416685980520830365227303101263220236115846257527363406328867070133263900860663213557708577848719178814761347152620792372847762483281132577137885981623016382936239562664037534610728652936498358752385455426412465419275613674679023680184197311118816809602224346016670679758338521715152362623465755928516580959
e = 166612997784562961050427402417959231610727289110449701096278048384004974210290958240913379674222687635734122544375614765473080442343653698415642775890353274310399072042600668814731842221602949909207395384402750419354408938463901094165980590478308424439117927846922386509060315654925327343542424625687693632068
ct = 17273356561619461078492198358303284146147837550026408083524518067748963714274545090109597771904129978632339754019199704530534497145745599609523527982760088915455559056009877592308177940333975618592015789383850494306210308069932391687742058641729313031291497958105019656727012043907079761118369894363732951513833446149610076031667795704343794624910397891428467219520881918134803714315257669793473836503542698570979981732999911129987227518836611490653123917494699687532642255114180923045867064695532251042613174669465051256868327606783121329453124577844785770741291338048163170224764870183574855853190001231864675756254

# Шаг 1: Восстанавливаем p
p = e - 65537  # e = 65537 + p
assert n % p == 0, "Ошибка: p не делит n"
q = n // p

# Шаг 2: Вычисляем φ(n) и d
phi = (p - 1) * (q - 1)
d = pow(65537, -1, phi)  # Исходное e = 65537

# Шаг 3: Расшифровываем
m = pow(ct, d, n)
flag = m.to_bytes((m.bit_length() + 7) // 8, byteorder='big').decode()

print("Флаг:", flag)
```

## Немного про RSA
### Генерация ключей:
1. Выбираем два простых числа p и q
2. Вычисляем n=p*q
3. Функция Эйлера: phi(n)=(p-1)*(q-1)
4. e=65537 - открытая экспонента, 1<e<phi(n), обычно 65537
5. Закрытая экспонента d=e<sup>-1</sup> mod phi(n) на python d=pow(e,-1,phi(n))

### Шифрование:
Чтобы зашифровать сообщение m, его зашифровывают с помощью отрытого ключа (e,n)
c=m<sup>e</sup>mod n
c - зашифрованное сообщение
m - исходное

### Расшифрование:
Чтобы зашифровать сообщение m, его зашифровывают с помощью закрытого ключа (d,n)
m=c<sup>d</sup>mod n
c - зашифрованное сообщение
m - исходное
